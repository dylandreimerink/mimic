// This binary generates the source code for the CPU instructions of the eBPF machine
//
// go run cmd/inst_gen/main.go | gofmt > inst_gen.go
package main

import (
	"fmt"
	"os"
	"text/template"

	"github.com/cilium/ebpf/asm"
)

type AluOp struct {
	BPFOp asm.ALUOp
	GoOp  string
}

var aluOps = []AluOp{
	{BPFOp: asm.Add, GoOp: "+"},
	{BPFOp: asm.Sub, GoOp: "-"},
	{BPFOp: asm.Mul, GoOp: "*"},
	{BPFOp: asm.Div, GoOp: "/"},
	{BPFOp: asm.Or, GoOp: "|"},
	{BPFOp: asm.And, GoOp: "&"},
	{BPFOp: asm.LSh, GoOp: "<<"},
	{BPFOp: asm.RSh, GoOp: ">>"},
	{BPFOp: asm.Mod, GoOp: "%"},
	{BPFOp: asm.Xor, GoOp: "^"},
}

type JumpOp struct {
	BPFOp  asm.JumpOp
	GoOp   string
	Signed bool
}

var jumpOps = []JumpOp{
	{BPFOp: asm.JEq, GoOp: "=="},
	{BPFOp: asm.JGT, GoOp: ">"},
	{BPFOp: asm.JGE, GoOp: ">="},
	{BPFOp: asm.JNE, GoOp: "!="},
	{BPFOp: asm.JSGT, GoOp: ">", Signed: true},
	{BPFOp: asm.JSGE, GoOp: ">=", Signed: true},
	{BPFOp: asm.JLT, GoOp: "<"},
	{BPFOp: asm.JLE, GoOp: "<="},
	{BPFOp: asm.JSLT, GoOp: "<", Signed: true},
	{BPFOp: asm.JSLE, GoOp: "<=", Signed: true},
}

type KV struct {
	Key   string
	Value string
}

var insts = make([]*KV, 255)

func main() {
	var err error
	fmt.Print(header)

	alu32Class := asm.OpCode(asm.ALUClass)
	alu64Class := asm.OpCode(asm.ALU64Class)
	for _, op := range aluOps {
		// The 32bit IMM variant
		asmOp := alu32Class.SetALUOp(op.BPFOp)
		err = alu32Imm.Execute(os.Stdout, op)
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.ALUClass).SetALUOp(asm.%s)", op.BPFOp),
			Value: fmt.Sprintf("InstALU32%sIMM", op.BPFOp),
		}

		// The 64bit IMM variant
		asmOp = alu64Class.SetALUOp(op.BPFOp)
		err = alu64Imm.Execute(os.Stdout, op)
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.ALU64Class).SetALUOp(asm.%s)", op.BPFOp),
			Value: fmt.Sprintf("InstALU64%sIMM", op.BPFOp),
		}

		// The 32bit Regs variants
		asmOp = alu32Class.SetALUOp(op.BPFOp) | asm.OpCode(asm.RegSource)
		err = alu32Reg.Execute(os.Stdout, op)
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.ALUClass).SetALUOp(asm.%s) | asm.OpCode(asm.RegSource)", op.BPFOp),
			Value: fmt.Sprintf("InstALU32%sReg", op.BPFOp),
		}

		// The 64bit Regs variants
		asmOp = alu64Class.SetALUOp(op.BPFOp) | asm.OpCode(asm.RegSource)
		err = alu64Reg.Execute(os.Stdout, op)
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.ALU64Class).SetALUOp(asm.%s) | asm.OpCode(asm.RegSource)", op.BPFOp),
			Value: fmt.Sprintf("InstALU64%sReg", op.BPFOp),
		}
	}

	jump32Class := asm.OpCode(asm.Jump32Class)
	jump64Class := asm.OpCode(asm.JumpClass)
	for _, op := range jumpOps {
		// The 32bit IMM variant
		asmOp := jump32Class.SetJumpOp(op.BPFOp)
		if op.Signed {
			err = jump32ImmSigned.Execute(os.Stdout, op)
		} else {
			err = jump32Imm.Execute(os.Stdout, op)
		}
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.Jump32Class).SetJumpOp(asm.%s)", op.BPFOp),
			Value: fmt.Sprintf("InstJump32%sIMM", op.BPFOp),
		}

		// The 64bit IMM variant
		asmOp = jump64Class.SetJumpOp(op.BPFOp)
		if op.Signed {
			err = jump64ImmSigned.Execute(os.Stdout, op)
		} else {
			err = jump64Imm.Execute(os.Stdout, op)
		}
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.JumpClass).SetJumpOp(asm.%s)", op.BPFOp),
			Value: fmt.Sprintf("InstJump64%sIMM", op.BPFOp),
		}

		// The 32bit Regs variants
		asmOp = jump32Class.SetJumpOp(op.BPFOp) | asm.OpCode(asm.RegSource)
		if op.Signed {
			err = jump32RegSigned.Execute(os.Stdout, op)
		} else {
			err = jump32Reg.Execute(os.Stdout, op)
		}
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.JumpClass).SetJumpOp(asm.%s) | asm.OpCode(asm.RegSource)", op.BPFOp),
			Value: fmt.Sprintf("InstJump32%sReg", op.BPFOp),
		}

		// The 64bit Regs variants
		asmOp = jump64Class.SetJumpOp(op.BPFOp) | asm.OpCode(asm.RegSource)
		if op.Signed {
			err = jump64RegSigned.Execute(os.Stdout, op)
		} else {
			err = jump64Reg.Execute(os.Stdout, op)
		}
		if err != nil {
			panic(err)
		}
		insts[asmOp] = &KV{
			Key:   fmt.Sprintf("asm.OpCode(asm.ALU64Class).SetJumpOp(asm.%s) | asm.OpCode(asm.RegSource)", op.BPFOp),
			Value: fmt.Sprintf("InstJump64%sReg", op.BPFOp),
		}
	}

	err = initGen.Execute(os.Stdout, insts)
	if err != nil {
		panic(err)
	}
}

var header = `
package mimic

// Code generated by 'go run inst_gen.go | gofmt > inst.go' DO NOT EDIT

import "github.com/cilium/ebpf/asm"

`

var alu32Imm = template.Must(template.New("tpl").Parse(`
func InstALU32{{.BPFOp.String}}IMM (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	return process.Registers.Set(i.Dst, uint64(uint32(dst) {{.GoOp}} uint32(i.Constant)))
}
`))

var alu32Reg = template.Must(template.New("tpl").Parse(`
func InstALU32{{.BPFOp.String}}Reg (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	src := process.Registers.Get(i.Src)
	return process.Registers.Set(i.Dst, uint64(uint32(dst) {{.GoOp}} uint32(src)))
}
`))

var alu64Imm = template.Must(template.New("tpl").Parse(`
func InstALU64{{.BPFOp.String}}IMM (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	return process.Registers.Set(i.Dst, dst {{.GoOp}} uint64(i.Constant))
}
`))

var alu64Reg = template.Must(template.New("tpl").Parse(`
func InstALU64{{.BPFOp.String}}Reg (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	src := process.Registers.Get(i.Src)
	return process.Registers.Set(i.Dst, dst {{.GoOp}}src)
}
`))

var jump32Imm = template.Must(template.New("tpl").Parse(`
func InstJump32{{.BPFOp.String}}IMM (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	if uint32(dst) {{.GoOp}} uint32(i.Constant) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump64Imm = template.Must(template.New("tpl").Parse(`
func InstJump64{{.BPFOp.String}}IMM (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	if dst {{.GoOp}} uint64(i.Constant) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump32Reg = template.Must(template.New("tpl").Parse(`
func InstJump32{{.BPFOp.String}}Reg (i asm.Instruction, process *Process) error {
	src := process.Registers.Get(i.Src)
	dst := process.Registers.Get(i.Dst)
	if uint32(dst) {{.GoOp}} uint32(src) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump64Reg = template.Must(template.New("tpl").Parse(`
func InstJump64{{.BPFOp.String}}Reg (i asm.Instruction, process *Process) error {
	src := process.Registers.Get(i.Src)
	dst := process.Registers.Get(i.Dst)
	if dst {{.GoOp}} src {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump32ImmSigned = template.Must(template.New("tpl").Parse(`
func InstJump32{{.BPFOp.String}}IMM (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	if int32(dst) {{.GoOp}} int32(i.Constant) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump64ImmSigned = template.Must(template.New("tpl").Parse(`
func InstJump64{{.BPFOp.String}}IMM (i asm.Instruction, process *Process) error {
	dst := process.Registers.Get(i.Dst)
	if int64(dst) {{.GoOp}} int64(i.Constant) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump32RegSigned = template.Must(template.New("tpl").Parse(`
func InstJump32{{.BPFOp.String}}Reg (i asm.Instruction, process *Process) error {
	src := process.Registers.Get(i.Src)
	dst := process.Registers.Get(i.Dst)
	if int32(dst) {{.GoOp}} int32(src) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var jump64RegSigned = template.Must(template.New("tpl").Parse(`
func InstJump64{{.BPFOp.String}}Reg (i asm.Instruction, process *Process) error {
	src := process.Registers.Get(i.Src)
	dst := process.Registers.Get(i.Dst)
	if int64(dst) {{.GoOp}} int64(src) {
		process.Registers.PC += int(i.Offset)
	}
	
	return nil
}
`))

var initGen = template.Must(template.New("tpl").Parse(`
func initGen() { {{range . }}{{if . }}	instructions[{{ .Key }}] = {{ .Value }}
{{end}}{{end}} }
`))
